#!/usr/bin/env python3
"""
Visual Monte Carlo Pi Demo for Raspberry Pi Cluster
Each node shows its own computation visualization
"""

from mpi4py import MPI
import random
import time
import math
import numpy as np
import matplotlib

matplotlib.use('Agg')
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
import os
import subprocess
import shutil
import sys


def create_node_visualization(rank, size, my_samples, inside_count, elapsed_time, output_file):
    """
    Create a visualization for this specific node showing:
    - Points generated by this node
    - Node's contribution to Pi estimation
    - Performance metrics
    """

    # Sample points for visualization (max 2000 for performance)
    viz_samples = min(my_samples, 2000)
    random.seed(rank + int(time.time()))

    x_inside = []
    y_inside = []
    x_outside = []
    y_outside = []

    for _ in range(viz_samples):
        x = random.random()
        y = random.random()

        if x * x + y * y <= 1.0:
            x_inside.append(x)
            y_inside.append(y)
        else:
            x_outside.append(x)
            y_outside.append(y)

    # Create figure
    fig = plt.figure(figsize=(12, 10))
    fig.patch.set_facecolor('white')

    # Main plot - Monte Carlo visualization
    ax1 = plt.subplot2grid((3, 2), (0, 0), rowspan=2, colspan=2)

    ax1.set_facecolor("white")
    # Plot points
    if x_outside:
        ax1.scatter(x_outside, y_outside, c='#e74c3c', s=3, alpha=0.6, label='Outside')
    if x_inside:
        ax1.scatter(x_inside, y_inside, c='#3498db', s=3, alpha=0.6, label='Inside')

    # Draw quarter circle
    theta = np.linspace(0, np.pi / 2, 100)
    circle_x = np.cos(theta)
    circle_y = np.sin(theta)
    ax1.plot(circle_x, circle_y, '#2ecc71', linewidth=3, label='Quarter Circle')

    ax1.set_xlim(0, 1)
    ax1.set_ylim(0, 1)
    ax1.set_aspect('equal')
    # ax1 background already set to white
    ax1.grid(True, alpha=0.2, color='black')
    ax1.legend(loc='upper right', fontsize=20, facecolor='lightgray', edgecolor='black')
    ax1.set_title(f'Node {rank} Monte Carlo Simulation',
                  fontsize=32, color='black', fontweight='bold', pad=15)

    # Remove tick labels for cleaner look
    ax1.set_xticks([])
    ax1.set_yticks([])

    # Bottom left - Node Info
    ax2 = plt.subplot2grid((3, 2), (2, 0))
    ax2.axis('off')
    ax2.set_facecolor('white')

    node_efficiency = (inside_count / my_samples) if my_samples > 0 else 0
    throughput = my_samples / elapsed_time if elapsed_time > 0 else 0

    info_text = f"""
    NODE INFORMATION

    Rank:           {rank} / {size - 1}
    Samples:        {my_samples:,}
    Inside Circle:  {inside_count:,}
    Outside Circle: {my_samples - inside_count:,}

    Time:           {elapsed_time:.3f} sec
    Throughput:     {throughput:,.0f} samples/s
    """

    ax2.text(0.1, 0.5, info_text, fontsize=22, color='black',
             family='monospace', verticalalignment='center',
             bbox=dict(boxstyle='round', facecolor='lightgray',
                       edgecolor='#3498db', linewidth=2))

    # Bottom right - Contribution
    ax3 = plt.subplot2grid((3, 2), (2, 1))
    ax3.axis('off')
    ax3.set_facecolor('white')

    my_pi_estimate = 4.0 * inside_count / my_samples if my_samples > 0 else 0
    error = abs(my_pi_estimate - math.pi)

    contrib_text = f"""
    MY CONTRIBUTION

    Local π estimate:  {my_pi_estimate:.6f}
    Actual π:          {math.pi:.6f}
    Error:             {error:.6f}

    Status: {'✓ COMPLETE' if elapsed_time > 0 else '⟳ RUNNING'}
    """

    ax3.text(0.05, 0.5, contrib_text, fontsize=22, color='black',
             family='monospace', verticalalignment='center',
             bbox=dict(boxstyle='round', facecolor='lightgray',
                       edgecolor='#2ecc71', linewidth=2))

    plt.tight_layout()
    plt.savefig(output_file, dpi=100, facecolor='black', edgecolor='black')
    plt.close()

    # Copy to shared /export directory
    import subprocess
    export_dir = "/export/infoTag2025/updated_scripts/applications/monte_carlo_pi/results"
    export_file = f"{export_dir}/node_{rank:03d}.png"
    try:
        shutil.copy(output_file, export_file)
    except:
        pass


def main():
    # Initialize MPI
    comm = MPI.COMM_WORLD
    rank = comm.Get_rank()
    size = comm.Get_size()

    # Configuration
    total_samples = 50_000_000  # 50 million total (default)
    if len(sys.argv) > 1:
        total_samples = int(sys.argv[1])

    samples_per_process = total_samples // size

    # Each process gets its share
    my_samples = samples_per_process
    if rank < (total_samples % size):
        my_samples += 1

    # Output directory - use environment variable if set, otherwise ./results
    output_dir = os.environ.get('RESULTS_DIR', './results')
    os.makedirs(output_dir, exist_ok=True)
    output_file = f"{output_dir}/node_{rank:03d}.png"

    # Computation
    random.seed(rank)
    inside_circle = 0

    start_time = time.time()

    for _ in range(my_samples):
        x = random.random()
        y = random.random()

        if x * x + y * y <= 1.0:
            inside_circle += 1

    elapsed_time = time.time() - start_time

    # Create visualization for this node
    create_node_visualization(rank, size, my_samples, inside_circle,
                              elapsed_time, output_file)

    # Gather results at root
    total_inside = comm.reduce(inside_circle, op=MPI.SUM, root=0)

    # Root creates summary
    if rank == 0:
        pi_estimate = 4.0 * total_inside / total_samples
        error = abs(pi_estimate - math.pi)

        print("=" * 70)
        print("MONTE CARLO PI ESTIMATION - CLUSTER RESULTS")
        print("=" * 70)
        print(f"Total samples:    {total_samples:,}")
        print(f"Number of nodes:  {size}")
        print(f"Estimated π:      {pi_estimate:.10f}")
        print(f"Actual π:         {math.pi:.10f}")
        print(f"Error:            {error:.10f}")
        print(f"Time:             {elapsed_time:.3f} seconds")
        print("=" * 70)
        print(f"\nVisualizations saved to: {output_dir}/node_*.png")


if __name__ == "__main__":
    main()